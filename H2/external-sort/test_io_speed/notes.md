Исследование скоростей работы с файлами при помощи разных библиотек
===

Создаю файл 954 Mbyte и записываю его в res.txt

Результаты измерений:

## stdio.h
* *fopen*
  * Если файла нет, то 0.031 ms
  * Если файл есть, то от 82 ms до 93 ms
* *fwrite*:
  * Если файла нет, то 420 ms
  * Если файл есть, то 420 ms
* *fclose*:
  * Если файла не было, то 0.010 ms
  * Если файл был, то 413 ms - 960 ms

## unistd.h, fcntl2.h
* *open*
  * Если файла нет, то 0.009 ms
  * Если файл есть, то 0.009 ms
* *write*:
  * Если файла нет, то 411 ms
  * Если файл есть, то 183 ms - 210 ms
* *close*:
  * Если файла не было, то 0.004 ms
  * Если файл был, то 0.004 ms

## fstream
* *ofstream ctor*:
  * Если файла нет, то 0.049 ms
  * Если файл есть, то от 82 ms до 94 ms
* *os << str*:
  * Если файла нет, то 420 ms
  * Если файл есть, то 420 ms
* *ofstream ctor*:
  * Если файла не было, то 0.000 ms
  * Если файл был, то от 350 ms до 500 ms

# Пробуем ускорить
Чтобы ускорить *fopen*, нужно убрать у него опцию TRUNC.
Она появлется из-за "w" == O_CREAT | O_WRONLY | O_TRUNC.
Именна она и замедляет открытие, запись и закрытие файла.
```cpp
int fd = open ("input.txt", O_WRONLY | O_CREAT, 0666); // Нету O_TRUNC
FILE* file = fdopen (fd, "w");
if (file == nullptr) {
    throw std::runtime_error ("fopen");
}
```

Теперь (3 теста, изначально файла не было):

* fopen vs open:   35 12 12 vs 33 12 11       (mks)
* fwrite vs write: 412 187 183 vs 410 185 184 (ms)
* fclose vs close: 11 13 12 vs 3 4 5          (mks)

## Успех!

Видно, что откытие и запись файла полностью соптимизировались и стали как
чисто linux функции. Фукнция закрытия тоже перестала делать лишних действий, но
достичь производительности close пока не получилось (олтичие в 2-3 разаc)

# Пробуем ускорить C++ код
Самое важное для меня - это ZCO, поэтому ускорить C++ код является основной задачей.
Первая идея - отключить транк или найти реализацию, отключающую транк.

Нужно заменить буфер, которым пользуется *std::ostream*. Мы создадим его сами,
используя open. Это сильно ускорит процесс и в итоге выровнит perfomance
C++ версии с версией на голом C.

## Вопрос:
Если рассмотреть функцию *std::endl*, то можно заметить там использование
*->widen ('\n')*.
Но если посмотреть просто *std::cout << "Hi"*, то в итоге просто приходим
к встроенной функции копирования
